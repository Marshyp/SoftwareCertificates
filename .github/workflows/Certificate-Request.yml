name: Certificate Extraction from Issue

on:
  issues:
    types: [opened, edited]

jobs:
  extract_certificate:
    if: startsWith(github.event.issue.title, 'X-Certificate Request')
    runs-on: windows-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Parse Issue Body
        id: parse_issue
        shell: pwsh
        run: |
          # Capture the issue body
          $body = "${{ github.event.issue.body }}"

          # Extract Software Download Link
          if ($body -match "Software Download Link\s*\n\s*(.+)") {
              $downloadLink = $matches[1].Trim()
          } else {
              Write-Host "❌ Software Download Link not found!"
              exit 1
          }

          # Extract Certificate Name
          if ($body -match "Certificate Name\s*\n\s*(.+)") {
              $certificateName = $matches[1].Trim()
          } else {
              Write-Host "❌ Certificate Name not found!"
              exit 1
          }

          # Sanitize name
          $certificateName = $certificateName -replace "\+", "p" `
                                              -replace " ", "_" `
                                              -replace "\t", "" `
                                              -replace '[:\\/*?"<>|]', ""
          $certificateName = $certificateName -replace "_+", "_"
          if ($certificateName.Length -gt 50) {
              $certificateName = $certificateName.Substring(0, 50)
          }

          Write-Host "Link: $downloadLink"
          Write-Host "Name: $certificateName"

          Add-Content -Path $env:GITHUB_OUTPUT -Value "DOWNLOAD_LINK=$downloadLink"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "CERTIFICATE_NAME=$certificateName"

      - name: Check Platform
        id: check_platform
        shell: pwsh
        run: |
          $link = "${{ steps.parse_issue.outputs.DOWNLOAD_LINK }}"
          if ($link -imatch "arm64" -or ($link -imatch "x86" -and -not ($link -imatch "x64"))) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "PLATFORM_SUPPORTED=false"
          } else {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "PLATFORM_SUPPORTED=true"
          }

      - name: Unsupported Platform - Comment & Close
        if: steps.check_platform.outputs.PLATFORM_SUPPORTED == 'false'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "Unsupported platform detected. Please provide an x64 build."
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "closed"
            });

      - name: Download Software
        if: steps.check_platform.outputs.PLATFORM_SUPPORTED == 'true'
        id: download
        shell: pwsh
        run: |
          $link = "${{ steps.parse_issue.outputs.DOWNLOAD_LINK }}"
          $name = "${{ steps.parse_issue.outputs.CERTIFICATE_NAME }}"
          if (-not $name) { $name = "downloaded_software" }
          $ext = [System.IO.Path]::GetExtension($link); if (-not $ext) { $ext = ".exe" }
          $file = "$name$ext"

          try {
              Invoke-WebRequest -Uri $link -OutFile $file -ErrorAction Stop
              Add-Content -Path $env:GITHUB_OUTPUT -Value "DOWNLOAD_SUCCESS=true"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "SOFTWARE_FILE=$file"
          } catch {
              Write-Host "Download failed."
              Add-Content -Path $env:GITHUB_OUTPUT -Value "DOWNLOAD_SUCCESS=false"
          }

      - name: Invalid Download Link Comment
        if: steps.download.outputs.DOWNLOAD_SUCCESS == 'false'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "Invalid download link—please check and update."
            });

      - name: Extract Signing Certificate
        if: steps.download.outputs.DOWNLOAD_SUCCESS == 'true'
        id: extract_certificate
        shell: pwsh
        run: |
          $file = "${{ steps.download.outputs.SOFTWARE_FILE }}"
          $name = "${{ steps.parse_issue.outputs.CERTIFICATE_NAME }}"

          # Root‐level “All Certs Uncategorized” folder
          $certDir = "All Certs Uncategorized"
          if (-not (Test-Path $certDir)) {
              New-Item -ItemType Directory -Path $certDir | Out-Null
          }

          $certPath = Join-Path $certDir "$name.cer"
          $found = $false

          try {
              Unblock-File -Path $file
              $sig = Get-AuthenticodeSignature -FilePath $file
              $cert = $sig.SignerCertificate ?: $sig.TimeStampSignerCertificate
              if ($cert) {
                  [IO.File]::WriteAllBytes($certPath, $cert.Export("Cert"))
                  $found = $true
                  Write-Host "Extracted to $certPath"
              } else {
                  Write-Host "No certificate found."
              }
              Remove-Item -Path $file -Force
          } catch {
              Write-Host "Error: $_"
          }

          Add-Content -Path $env:GITHUB_OUTPUT -Value "CERTIFICATE_FOUND=$found"

      - name: Certificate Extracted - Comment & Close
        if: steps.extract_certificate.outputs.CERTIFICATE_FOUND == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "Certificate extracted into **All Certs Uncategorized**. Thanks!"
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "closed"
            });

      - name: Commit Extracted Certificate
        if: steps.extract_certificate.outputs.CERTIFICATE_FOUND == 'true'
        shell: pwsh
        run: |
          $name = "${{ steps.parse_issue.outputs.CERTIFICATE_NAME }}"
          $certFile = "All Certs Uncategorized/$name.cer"

          git config --local user.name "github-actions"
          git config --local user.email "action@github.com"
          git add $certFile
          git commit -m "Add extracted certificate: $name.cer" || Write-Host "Nothing to commit"
          git push

      - name: No Certificate Found - Comment & Close
        if: steps.extract_certificate.outputs.CERTIFICATE_FOUND == 'false'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "No certificate was found in the software. Closing issue."
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "closed"
            });
